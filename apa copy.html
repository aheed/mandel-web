<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>Mandel WebGPU</title>
  </head>
  <body>
    <canvas width="1024" height="1024"></canvas>
    <script type="module">
      const WORKGROUP_SIZE = 8;

      const canvas = document.querySelector("canvas");

      // WebGPU device initialization
      if (!navigator.gpu) {
        throw new Error("WebGPU not supported on this browser.");
      }

      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) {
        throw new Error("No appropriate GPUAdapter found.");
      }

      const device = await adapter.requestDevice();

      console.log("so far so good 1");

      console.log(device.limits);

      const module = device.createShaderModule({
        code: `
          @group(0) @binding(0)
          var<storage, read> input: array<f32>;

          @group(0) @binding(1)
          var<storage, read_write> output: array<f32>;

          @compute @workgroup_size(64)
          fn main(

            @builtin(global_invocation_id)
            global_id : vec3<u32>,

            @builtin(local_invocation_id)
            local_id : vec3<u32>,

          ) {
            if(global_id.x >= arrayLength(&output)) {
              return;
            }

            output[global_id.x] =
              f32(global_id.x) * 1000. + f32(local_id.x) +
               input[local_id.x % 2];
          }
        `,
      });

      const bindGroupLayout =
        device.createBindGroupLayout({
            entries: [{
              binding: 0,
              visibility: GPUShaderStage.COMPUTE,
              buffer: {
                type: "read-only-storage",
              },
            },{
              binding: 1,
              visibility: GPUShaderStage.COMPUTE,
              buffer: {
                type: "storage",
              },
            }],
          });

      const pipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
          bindGroupLayouts: [bindGroupLayout],
        }),
        compute: {
          module,
          entryPoint: "main",
        },
      });

      const BUFFER_SIZE = 1000;

      const input = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      });

      const output = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
      });

      const stagingBuffer = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      });

      const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: {
            buffer: input,
          },
        },{
          binding: 1,
          resource: {
            buffer: output,
          },
        }],
      });



      const commandEncoder = device.createCommandEncoder();
      const passEncoder = commandEncoder.beginComputePass();
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.dispatchWorkgroups(1);
      passEncoder.dispatchWorkgroups(Math.ceil(BUFFER_SIZE / 64));
      passEncoder.end();
      commandEncoder.copyBufferToBuffer(
        output,
        0, // Source offset
        stagingBuffer,
        0, // Destination offset
        BUFFER_SIZE
      );
      const commands = commandEncoder.finish();

      let inputBalls = new Float32Array(new ArrayBuffer(BUFFER_SIZE));
      inputBalls[0] = 0.01;
      inputBalls[1] = 0.03;

      device.queue.writeBuffer(input, 0, inputBalls);
      device.queue.submit([commands]);

      await stagingBuffer.mapAsync(
        GPUMapMode.READ,
        0, // Offset
        BUFFER_SIZE // Length
      );
      const copyArrayBuffer =
        stagingBuffer.getMappedRange(0, BUFFER_SIZE);
      const data = copyArrayBuffer.slice();
      stagingBuffer.unmap();
      console.log(new Float32Array(data));


      console.log("so far so good  2");

    </script>
  </body>
</html>