<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>Mandel WebGPU</title>
  </head>
  <body>
    <canvas id="mandel-canvas" width="512" height="512"></canvas>
    <canvas id="mandel-canvas2" width="256" height="256"></canvas>
    <div id="status-msg"></div>
    <script type="module">
      const WORKGROUP_SIZE = 8;

      const canvas = document.querySelector("#mandel-canvas");
      const canvas2 = document.querySelector ("#mandel-canvas2");
      const statusMsg = document.querySelector("div");

      const urlParams = new URLSearchParams(window.location.search);

      const rPixels = 512;
      const iPixels = 512;
      

      // WebGPU device initialization
      if (!navigator.gpu) {
        const errMsg = "WebGPU not supported on this browser.";
        statusMsg.innerText = errMsg;
        throw new Error(errMsg);
      }

      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) {
        const errMsg = "No appropriate GPUAdapter found.";
        statusMsg.innerText = errMsg;
        throw new Error(errMsg);
      }

      const device = await adapter.requestDevice();

      console.log("so far so good 1");

      console.log(device.limits);

      statusMsg.innerText = "Rendering...";

      const module = device.createShaderModule({
        code: `
          @group(0) @binding(0)
          var<storage, read> input: array<f32>;

          @group(0) @binding(1)
          var<storage, read_write> output: array<f32>;

          var<private> max_iterations: u32 = 2000;
          var<private> max_gray_shade:u32 = 255;

          fn gray_shade(iterations: u32) -> u32 {
            return max_gray_shade - (max_gray_shade * iterations) / max_iterations;
          }

          fn gray_shade2(iterations: u32) -> u32 {
            if(iterations >= max_iterations) {
              return 0;
            }

            var a = f32(max_gray_shade) / 2;

            var cycles = 1.1;
            var pi = 3.14159;
            var b = 2 * pi * cycles / f32(max_iterations);

            var shade = a * (sin((b * f32(iterations))) + 1.0);
            return u32(shade);
          }

          fn mandel_iterations(r_val0: f32, i_val0: f32) -> u32 {
            var r_val = r_val0;
            var i_val = i_val0;

            var iterations: u32 = 0;
            
            for(iterations = 0; (r_val * r_val + i_val * i_val <= (2 * 2)) && (iterations < max_iterations); iterations = iterations + 1) {
              var r_temp = r_val * r_val - i_val * i_val + r_val0;
              i_val = 2 * r_val * i_val + i_val0;
              r_val = r_temp;
            }

            return iterations;
          }

          fn mandel_iterations_oversampled(r_val0: f32, i_val0: f32, r_delta: f32, i_delta: f32) -> u32 {
            var iterations_avg = 
              mandel_iterations(r_val0, i_val0) +
              mandel_iterations(r_val0 + r_delta, i_val0 + i_delta) +
              mandel_iterations(r_val0 + r_delta, i_val0) +
              mandel_iterations(r_val0 + r_delta, i_val0 - i_delta) +
              mandel_iterations(r_val0, i_val0 - i_delta) +
              mandel_iterations(r_val0 - r_delta, i_val0 - i_delta) +
              mandel_iterations(r_val0 - r_delta, i_val0) +
              mandel_iterations(r_val0 - r_delta, i_val0 + i_delta) +
              mandel_iterations(r_val0, i_val0 + i_delta);

            iterations_avg = iterations_avg / 9;
            return iterations_avg;
          }

          @compute @workgroup_size(64)
          fn main(

            @builtin(global_invocation_id)
            global_id : vec3<u32>,

            @builtin(local_invocation_id)
            local_id : vec3<u32>,

          ) {
            if(global_id.x >= arrayLength(&output)) {
              return;
            }

            var r_size = input[4];
            var i_size = input[5];
            var r_pixels = u32(r_size);
            var i_pixels = u32(i_size);
            var r_width = input[2] - input[0];
            var i_width = input[3] - input[1];
            var r_delta = f32(r_width) / f32(r_pixels);
            var i_delta = f32(i_width) / f32(i_pixels);
            var delta_scale = 0.30;
            var r_delta_scaled = r_delta * delta_scale;
            var i_delta_scaled = i_delta * delta_scale;
            var r0 = input[0];
            var i0 = input[1];
            var iterations: u32 = 0;

            if(global_id.x >= u32(r_pixels * i_pixels)) {
              iterations = max_iterations;
            }
            else {
              var r_index = global_id.x % r_pixels;
              var i_index = global_id.x / r_pixels;
              var r_val0 = r0 + f32(r_index) * r_delta;
              var i_val0 = i0 + f32(i_index) * i_delta;
              
              //iterations = mandel_iterations(r_val0, i_val0);
              iterations = mandel_iterations_oversampled(r_val0, i_val0, r_delta_scaled, i_delta_scaled);
            }

            //var shade = gray_shade(iterations);
            var shade = gray_shade2(iterations);
            output[global_id.x] = f32(shade);
          }
        `,
      });

      const bindGroupLayout =
        device.createBindGroupLayout({
            entries: [{
              binding: 0,
              visibility: GPUShaderStage.COMPUTE,
              buffer: {
                type: "read-only-storage",
              },
            },{
              binding: 1,
              visibility: GPUShaderStage.COMPUTE,
              buffer: {
                type: "storage",
              },
            }],
          });

      const pipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
          bindGroupLayouts: [bindGroupLayout],
        }),
        compute: {
          module,
          entryPoint: "main",
        },
      });

      const BUFFER_SIZE = rPixels * iPixels * 4;

      const input = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      });

      const output = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
      });

      const stagingBuffer = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      });

      const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: {
            buffer: input,
          },
        },{
          binding: 1,
          resource: {
            buffer: output,
          },
        }],
      });



      const commandEncoder = device.createCommandEncoder();
      const passEncoder = commandEncoder.beginComputePass();
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.dispatchWorkgroups(1);
      passEncoder.dispatchWorkgroups(Math.ceil(BUFFER_SIZE / 64));
      passEncoder.end();
      commandEncoder.copyBufferToBuffer(
        output,
        0, // Source offset
        stagingBuffer,
        0, // Destination offset
        BUFFER_SIZE
      );
      const commands = commandEncoder.finish();

      const rMin = urlParams.get('rmin') ?? -2.0;
      const rMax = urlParams.get('rmax') ?? 2.0;
      const iMin = urlParams.get('imin') ?? -1.0;
      const iMax = urlParams.get('imax') ?? 1.0;
      console.log(rMin, rMax, iMin, iMax);

      let inputArr = new Float32Array(new ArrayBuffer(BUFFER_SIZE));
      inputArr[0] = rMin;
      inputArr[1] = iMin;
      inputArr[2] = rMax;
      inputArr[3] = iMax;

      inputArr[4] = rPixels;
      inputArr[5] = iPixels;

      device.queue.writeBuffer(input, 0, inputArr);
      device.queue.submit([commands]);

      await stagingBuffer.mapAsync(
        GPUMapMode.READ,
        0, // Offset
        BUFFER_SIZE // Length
      );
      const copyArrayBuffer =
        stagingBuffer.getMappedRange(0, BUFFER_SIZE);
      console.log(copyArrayBuffer);
      const data = copyArrayBuffer.slice();
      stagingBuffer.unmap();
      console.log(new Float32Array(data));


      console.log("so far so good  2");

      let pixelData = new Float32Array(data);
      const context = canvas.getContext('2d');
      const imageData = context.getImageData(0, 0, rPixels, iPixels);
      const pixels = imageData.data;
      let idx = 0;
      for (let x = 0; x < rPixels*iPixels; x++) {
        pixels[idx] = pixelData[x];
        idx++;
        pixels[idx] = pixelData[x];
        idx++;
        pixels[idx] = pixelData[x]
        ;
        idx++;
        pixels[idx] = 255;
        idx++;
      }
      context.putImageData(imageData, 0, 0);
      console.log(imageData);
      console.log("so far so good  3");

      statusMsg.innerText = "Done!";


    </script>
  </body>
</html>